Starting code feedback for Yew Shen, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.58 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week3, .git, Feedback, Week1, Week2

Found the following files in parent directory: README.md, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
# Whitelist
!.gitkeep
!README.md
!.gitignore
!/Code

# Blacklist
*~
*.tmp
#comment
*.py[co]
Sandbox
Results
.vscode
*.pdf
*~
*.aux
*.dvi
*.log
*.nav
*.out
*.snm
*.toc
Week2/Data/JustOaksData.csv
Week2/Data/bodymass.csv
Week3/Code/.Rhistory

**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# CMEE Coursework Repository

*Author: Yewshen Lim*

*Created: Oct 2020*

This repository contains all the work attempted by Yewshen within "The Multilingual Quantitative Biologist" book which is taught in the first term of the CMEE Course.

Visitors who wish to attempt the coursework can refer to https://mhasoba.github.io/TheMulQuaBio/intro.html

Each individual subdirectory will contain their own READMEs detailing the contents within the week. Also located within each subdirectories are another 3 subdirectories /Code, /Results and /Data. /Code contains the scripts, /Results contains the output from the scripts and /Data contains input files for the scripts. One point to highlight is that if input files are only manipulated (e.g. changing file type and/or replacing separators), the output remains in /Data. Outputs are only directed to /Results when the input files were processed (e.g. generating a graph from a dataset).

## Table of Contents
1. Week 1: UNIX and Linux, shell scripting, git and Latex
2. Week 2: Biological Computing in Python
3. Week 3: Biological Computing in R


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: Data, Code, Results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# Week 3

*Author: Yewshen Lim*

*Created: Week 3*

This directory contains the scripts, data and results from week 2

Languages used in this week:
1. R
2. Python
3. LaTeX
4. Bash

Requirements:
1. R v 3.6 and above
    - tidyverse (which includes ggplot2, reshape2, dplyr, tidyr)
    - maps
2. Python3
    - numpy
    - time
3. LaTeX
4. A terminal running bash

## Scripts

### 1. `basic_io.R`

A simple script to illustrate R input-output

### 2. `control_flow.R`

Script illustrates the use of control flow in R

### 3. `break.R`

Script illustrates how to break out of a loop

### 4. `next.R`

Script illustrates the use of next

### 5. `boilerplate.R`

A boilerplate R script

### 6. `R_conditionals.R`

Script illustrates the use of conditionals

### 7. `TreeHeight.R`

Script contains a function that calculates heights of trees given distance of 
each tree from its base and angle to its top, using the trigonometric formula. 
Script takes input, applies TreeHeight function and writes output to a csv 
file in results

### 8. `Vectorize1.R`

Script illustrates vectorization, where it is an approach which directly 
applies compiled, optimized code to run an operation on a vector, matrix or a 
higher-dimensional data structure (like an R array), instead of performing the 
operation element-wise on the data structure. Script compares the speed between 
the vectorized and non-vectorized functions.

### 9. `preallocate.R`

Script illustrates how preallocation speeds up a loop that resizes a vector 
repeatedly

### 10. `apply1.R`

Script illustrates the use of apply to apply a function to rows/columns of a 
matrix

### 11. `apply2.R`

Script contains a function SomeOperation, which takes an input v, if sum of v 
is greater than zero, the function multiplies that value by 100. So if v has 
positive and negative numbers, and the sum comes out to be positive, only then 
does it multiply all the valus in v by 100 and return them

### 12. `sample.R`

This script illustrates how lapply and sapply work and also how to sample 
random numbers

### 13. `Ricker.R`

This script runs a simulation of the Ricker model and returns a vector of 
length generations

### 14. `Vectorize2.R`

This script runs the stochastic Ricker equation with gaussian fluctuations, 
and the attempt to vectorize the function

### 15. `browse.R`

Script illustrates the use of browser function to debug

### 16. `try.R`

Script illustrates the use of try function to "catch" errors

### 17. `TAutoCorr.R`

Script calculates the correlation between n - 1 pairs of years, where n is the 
total number of years. Generates a plot of the data which is saved as a pdf

### 18. `TAutoCorr.tex`

Script compiles the report which presents the results and interpretation of TAutoCorr.R into a pdf

### 19. `DataWrang.R`

Script uses base R packages to wrangle the Pound Hill Dataset

### 20. `DataWrangTidy.R`

Script uses tidyverse (specifically dplyr and tidyr) for the same data wrangling steps in DataWrang.R

### 21. `PP_Dists.R`

Script draws and saves three figures, each containing subplots of distributions of predator mass, prey mass, and the size ration of prey mass over predator mass by feeding interaction type. Use logarithms of masses (or size ratios) for all three plots. In addition, the script should calculate the (log) mean and median predator mass, prey mass and predator-prey size-ratios to a csv file

### 22. `Girko.R`

Script plots the Girko's law simulation, and saves the resulting figure to the results directory

### 23. `MyBars.R`

Script demonstrates how to annotate a plot and saves the resulting figure to the results directory

### 24. `plotLin.R`

Script demonstrates mathematical annotation on an axis and in the plot area, and saves the resulting figure to the results directory

### 25. `PP_Regress.R`

Script draws and saves a pdf of regression analysis and writes the accompanying regression results to a formatted table in csv in the results directory

### 26. `GPDD_Data.R`

Script creates a world map and superimposes it on all the locations from which data were provided in the GPDD dataframe

## Groupwork

### 1. `Vectorize1.py`

Python version of Vectorize1.R

### 2. `Vectorize2.py`

Python version of Vectorize2.R

### 3. `bashscript to compare speeds`

Script runs Vectorize 1 and 2 in both R and python for speed comparison

### 4. `get_TreeHeight.R`

Script takes an input file, applies the function TreeHeight.R, and outputs the result to a file which includes the input file name, e.g. InputFileName_treeheights.csv

### 5. `run_get_TreeHeight.sh`

Script runs get_TreeHeight.R and get_TreeHeight.py (script below) with the argument trees.csv

### 6. `get_TreeHeight.py`

Python version of get_TreeHeight.R

### 7. `PP_Regress_loc.R`

Script does the same as PP_Regress.R but data is additionally subset by the Location field and only outputs the analysis results to a csv in the results directory
**********************************************************************

Found following files in results directory: MyData.csv, Prey_Subplots.pdf, Pred_Subplots.pdf, PP_Results.csv, MyBars.pdf, Girko.pdf, PP_Regress_Results.csv, TACplot2.pdf, PP_Regress_Results.pdf, TACplot1.pdf, plotLin.pdf, SizeRatio_Subplots.pdf, TreeHts.csv...

Ideally, Results directory should be empty other than, perhaps a .gitkeep. 

 0.5 pts deducted per results file 

Current Points = 93.5

Found 26 code files: TreeHeight.R, browse.R, preallocate.R, plotLin.R, PP_Dists.R, TAutoCorr.tex, try.R, Vectorize2.R, TAutoCorr.R, boilerplate.R, apply1.R, PP_Regress.R, MyBars.R, DataWrang.R, control_flow.R, Vectorize1.R, sample.R, apply2.R, Ricker.R, break.R, next.R, R_conditionals.R, Girko.R, GPDD_Data.R, basic_io.R, DataWrangTidy.R

Found the following extra files: TAutoCorr.pdf, Rplots.pdf
0.5 pt deducted per extra file

Current Points = 92.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: TreeHeight.R
# Created: Oct 2020
#
# Script contains a function that calculates heights of trees given distance of
# each tree from its base and angle to its top, using the trigonometric formula.
# Script takes input, applies TreeHeight function and writes output to a csv
# file in results
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees: The angle of elevation of tree
# distance: The distance from base of tree (e.ge, meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

rm(list = ls())

# Read trees.csv file
TreeData <- read.csv("../Data/trees.csv", header = TRUE)


TreeHeight <- function(degrees, distance) {
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    print(paste("Tree height is:", height))

    return(height)
}

# Add output of TreeHeight for each tree to new column in TreeData
TreeData$Tree.Height.m <- TreeHeight(TreeData$Distance.m,
 TreeData$Angle.degrees)

# Write to TreeHts.csv file in Results
write.csv(TreeData, "../Results/TreeHts.csv")
**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
  [1] "Tree height is: 25.462680727681"  "Tree height is: 46.094124200205" 
  [3] "Tree height is: 15.2541806244397" "Tree height is: 16.1085376231346"
  [5] "Tree height is: 38.9782891142089" "Tree height is: 38.3661074268043"
  [7] "Tree height is: 17.5786750610666" "Tree height is: 28.5504607023457"
  [9] "Tree height is: 22.5701474298691" "Tree height is: 30.257477966697" 
 [11] "Tree height is: 29.5780499696015" "Tree height is: 30.2964612354713"
 [13] "Tree height is: 28.2539753999049" "Tre
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.18102s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: browse.R
# Created: Oct 2020
#
# Script illustrates the use of browser function to debug

rm(list = ls())

Exponential <- function(N0 = 1, r = 1, generations = 10) {
    # Runs a simulation of exponential growth
    # Returns a vector of length generations

    N <- rep(NA, generations) # Creates a vector of NA

    N[1] <- N0
    for (t in 2:generations) {
        N[t] <- N[t - 1] * exp(r)
        browser()
    }
    return(N)
}

plot(Exponential(), type = "l", main = "Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.25872s

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: preallocate.R
# Created: Oct 2020
#
# Script illustrates how preallocation speeds up a loop that resizes a vector
# repeatedly

rm(list = ls())

a <- NA
nopreallo <- function(a) {
    for (i in 1:10000) {
        a <- c(a, i)
        # print(a)
        # print(object.size(a))
    }
}

print("Without preallocation, time taken is:")
print(system.time(nopreallo(a)))

a <- rep(NA, 10000)
preallo <- function(a) {
    for (i in 1:10000) {
        a[i] <- i
        # print(a)
        # print(object.size(a))
    }
}

print("With preallocation, time taken is:")
print(system.time(preallo(a)))
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Without preallocation, time taken is:"
   user  system elapsed 
  0.152   0.028   0.179 
[1] "With preallocation, time taken is:"
   user  system elapsed 
  0.004   0.000   0.003 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.41281s

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: plotLin.R
# Created: Nov 2020
#
# This script demonstrates mathematical annotation on an axis and in the plot
# area, and saves the resulting figure to the results directory

rm(list = ls())

require(ggplot2)

x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

pdf("../Results/plotLin.pdf")
p
dev.off()
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************
null device 
          1 

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2

======================================================================
Inspecting script file PP_Dists.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: PP_Dists.R
# Created: Oct 2020
#
# This script draws and saves three figures, each containing subplots of
# distributions of predator mass, prey mass, and the size ratio of prey mass
# over predator mass by feeding interaction type. Use logarithms of masses
# (or size ratios) for all three plots. In addition, the script should calculate
# the (log) mean and median predator mass, prey mass and predator-prey
# size-ratios to a csv file

# clear out workspace
rm(list = ls())

# packages
require(dplyr)

# load data
df <- read.csv("../Data/EcolArchives-E089-51-D1.csv")

# explore data
dim(df)
dplyr::glimpse(df)

# convert masses from mg to g
for (i in 1:nrow(df)){
  if (df$Prey.mass.unit[i] == "mg"){
    df$Prey.mass.unit[i] = "g"
    df$Prey.mass[i] = df$Prey.mass[i] / 1000
  }
}

# pred subplots.pdf
pdf("../Results/Pred_Subplots.pdf")
par(mfrow = c(2, 3))
for (i in unique(df$Type.of.feeding.interaction)) {
  j <- subset(df, Type.of.feeding.interaction == i)
  plot(density(log(j$Predator.mass)), main = i, col = "steelblue", frame = F,
       xlab = "log of Predator mass",
       xlim = c(-10, 10),
       ylim = c(0.0, 0.4))
}
dev.off()

# prey subplots.pdf
pdf("../Results/Prey_Subplots.pdf")
par(mfrow = c(2, 3))
for (i in unique(df$Type.of.feeding.interaction)) {
  j <- subset(df, Type.of.feeding.interaction == i)
  plot(density(log(j$Prey.mass)), main = i, col = "steelblue", frame = F,
       xlab = "log of Prey mass",
       xlim = c(-20, 10),
       ylim = c(0.0, 0.4))
}
dev.off()

# size ratio_subplots.pdf
pdf("../Results/SizeRatio_Subplots.pdf")
par(mfrow = c(2, 3))
for (i in unique(df$Type.of.feeding.interaction)) {
  j <- subset(df, Type.of.feeding.interaction == i)
  plot(density(log(j$Prey.mass/j$Predator.mass)), main = i, col = "steelblue",
       frame = F,
       xlab = "log of Prey mass / Predator mass",
       xlim = c(-20, 5),
       ylim = c(0.0, 0.35))
}
dev.off()

# pp_results.csv
stats <- df %>%
  group_by(Type.of.feeding.interaction) %>%
  summarise(mean(log(Predator.mass)),
            median(log(Predator.mass)),
            mean(log(Prey.mass)),
            median(log(Prey.mass)),
            mean(log(Prey.mass / Predator.mass)),
            median(log(Prey.mass / Predator.mass)))
# name the columns
names(stats) <- c("Type.of.feeding.interaction",
                  "Mean.log.predator.mass",
                  "Median.log.predator.mass",
                  "Mean.log.prey.mass",
                  "Median.log.prey.mass",
                  "Mean.log.ratio.prey.predator.mass",
                  "Median.log.ratio.prey.predator.mass")
# write to csv
write.csv(stats, "../Results/PP_Results.csv")
**********************************************************************

Testing PP_Dists.R...

Output (only first 500 characters): 


**********************************************************************
[1] 34931    15
Rows: 34,931
Columns: 15
$ Record.number               <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13…
$ In.refID                    <chr> "ATSH063", "ATSH080", "ATSH089", "ATSH143…
$ IndividualID                <chr> "1", "2", "3", "4", "5", "6", "7", "8", "…
$ Predator                    <chr> "Rhizoprionodon terraenovae", "Rhizoprion…
$ Predator.common.name        <chr> "Atlantic sharpnose shark", "Atlantic sha…
$ Predator.taxon              <chr> "ectotherm vertebrate", "ecto
**********************************************************************

Encountered error or warning:
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

`summarise()` ungrouping output (override with `.groups` argument)

======================================================================
Inspecting script file TAutoCorr.tex...

File contents are:

**********************************************************************
\documentclass[12pt]{article}
\usepackage{graphicx}
\graphicspath{ {../Results/} }

\setlength{\parskip}{1em}

\title{Are temperatures of one year significantly correlated with the next year 
(successive years), across years in a given location?}

\author{Yewshen Lim}

\date{\today}


\begin{document}
\maketitle

\section{Introduction}
This paper investigates whether temperatures of one year significantly
correlates with the next year for successive years, across years in a 
given location.

The null hypothesis states that temperatures of one year do not 
significantly correlate with the next year for successive years, across
years in a given location. The alternative hypothesis states that 
temperatures are correlated. Temperature data across multiple years in 
Key West, Florida is being investigated in this paper.

A significance level of less than 0.05 is required for the correlation to be
significant. However, temperature data between years are not independent, thus 
samples of randomly ordered temperature data is generated in order to calculate
the p-value.

\begin{figure}[hbt!]
\centering
\includegraphics[width = 4in, height = 3in]{TACplot1.pdf}
\caption{A scatterplot showing the relationship between Temperatures 
(Degrees celcius) and Years at Key West, Florida.}
\label{fig:Fig1}
\end{figure}
    
\newpage
\section{Results}
The analysis calculates the correlation coefficient between successive 
years to be 0.326 (3 s.f.), which signifies that there is a slight 
positive correlation for temperatures between successive years.

\begin{figure}[hbt!]
\centering
\includegraphics[width = 4in, height = 3in]{TACplot2.pdf}
\caption{A histogram showing the distribution of correlation 
coefficients from randomly ordered temperatures.} 
\label{fig:Fig2}
\end{figure}

\newpage
Due to the random sampling, the p-value would fluctuate, however the 
seed had been set at 1 for reproducibility. The range of p-values 
obtained are much smaller than 0.05, which rejects the null hypothesis 
and accepts the alternative hypothesis where there is a strong 
significance in the correlation for temperatures between successive 
years. 

\end{document}
**********************************************************************

Testing TAutoCorr.tex...

Output (only first 500 characters): 


**********************************************************************
This is pdfTeX, Version 3.14159265-2.6-1.40.20 (TeX Live 2019/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(./TAutoCorr.tex
LaTeX2e <2020-02-02> patch level 2
L3 programming layer <2020-02-14>
(/usr/share/texlive/texmf-dist/tex/latex/base/article.cls
Document Class: article 2019/12/20 v1.4l Standard LaTeX document class
(/usr/share/texlive/texmf-dist/tex/latex/base/size12.clo))
(/usr/share/texlive/texmf-dist/tex/latex/graphics/graphicx.sty
(/usr/share/t
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.90824s

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: browse.R
# Created: Oct 2020
#
# Script illustrates the use of try function to "catch" errors

rm(list = ls())

# this function runs a simulation that involves sampling from a synthetic
# population with replacement and takes its mean, but only if at least 30 unique
# samples are obtained
doit <- function(x) {
    temp_x <- sample(x, replace = TRUE)
    if(length(unique(temp_x)) > 30) { # only take mean if sample was sufficient
        print(paste("Mean of this sample was:", as.character(mean(temp_x))))
    }
    else { # else stop the script
        stop("Couldn't calculate mean: too few unique values!")
    }
}

# generate populations
popn <- rnorm(50)

# visualize popn
hist(popn)

# lapply to repeat sampling 15 times
lapply(1:15, function(i) doit(popn))

# now use try
result <- lapply(1:15, function(i) try(doit(popn), FALSE))

# errors are stored in the object result:
class(result)

# use loop to store results "manually"
result <- vector("list", 15) # Preallocate/Initialize
for(i in 1:15) {
    result[[i]] <- try(doit(popn), FALSE)
}

# checkout tryCatch() as an alternative to try()
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.358906410172672"
[1] "Mean of this sample was: -0.00465711715105129"
[1] "Mean of this sample was: -0.0720994201911878"
[1] "Mean of this sample was: -0.212825239975875"
[1] "Mean of this sample was: -0.360019707347339"

**********************************************************************

Encountered error or warning:
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Calls: lapply -> FUN -> doit
Execution halted

======================================================================
Inspecting script file Vectorize2.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: Vectorize2.R
# Created: Oct 2020
#
# This script runs the stochastic Ricker equation with gaussian fluctuations,
# and the attempt to vectorize the function
#
# ARGUMENTS
# p0 = initial population density
# r = intrinsic growth rate
# K = carrying capacity of the environment
# sigma = environmental process noise s.d.
# numyears = number of years to loop over
#
# OUTPUT
# density of population after a number of generations

# clears workspace
rm(list = ls())

stochrick <- function(p0=runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,
                      numyears = 100) {

    #initialize
    N <- matrix(NA, numyears, length(p0))
    N[1, ] <- p0

    # loop through the populations
    for (pop in 1:length(p0)) {

        # for each pop, loop through the years
        for (yr in 2:numyears) {
            N[yr, pop] <- N[yr - 1, pop] * exp(r * (1 - N[yr - 1, pop] / K) +
            rnorm(1, 0, sigma))
        }
    }
    return(N)
}

# Now write another function called stochrickvect that vectorizes the above
# to the extent possible, with improved performance:
stochrickvect <- function(p0=runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,
                          numyears = 100) {

    # initialize N, 100 years x 1000 populations
    N <- matrix(NA, numyears, length(p0))
    # p0 is the starting number across all populations
    N[1, ] <- p0
    # how to vectorize:
    # can vectorize across all populations, but not within the populations
    # this is because all populations are independent
    # but within populations, there is dependency, N(t + 1) comes from N(t)
    for (yr in 2:numyears) {
        # by leaving N[, pop] blank, it lets the function work across all pop
        # at once
            N[yr, ] <- N[yr - 1, ] * exp(r * (1 - N[yr - 1, ] / K) +
            rnorm(1, 0, sigma))
        }
    # can skip looping through populations one by one, figure out how to apply
    # the equation across all populations at once
    return(N)
}

print("Non-vectorized Stochastic Ricker takes:")
print(system.time(res1 <- stochrick()))
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2 <- stochrickvect()))
**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Non-vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.250   0.020   0.272 
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.011   0.000   0.012 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.53710s

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: TAutoCorr.R
# Created: Oct 2020
#
# This script calculates the correlation between n - 1 pairs of years, where n
# is the total number of years. Generates a plot of the data which is saved as a
# pdf

# clear out workspace
rm(list = ls())

# set seed so results are reproducible
set.seed(1)

# load data
load("../Data/KeyWestAnnualMeanTemperature.RData")

# list the structure
ls.str(ats)

# plot
pdf("../Results/TACplot1.pdf")
plot(ats$Year, ats$Temp,
    xlab = "Year",
    ylab = "Temp (Degrees celcius)",
    type = "p")
dev.off()

# overall correlation
# compute the correlation between successive years T[y] against T[y+1]
# temp in y+1 is dependent on temp in y
T_y0 <- c(ats[1:99, 2])
T_y1 <- c(ats[2:100, 2])
cc0 <- cor(T_y0, T_y1)
cat("The correlation between successive years is", cc0)

# generating 10000 samples of random ordered temperatures
samples <- replicate(10000, sample(ats$Temp, replace = F))

# generate a vector of corr coeffs from the 10000 random samples
ccS <- vector("numeric", 10000)
for (i in 1:10000) {
    T_s <- cor(samples[1:99, i], samples[2:100, i])
    ccS[i] <- T_s
}

# histogram to compare coefficient correlations
pdf("../Results/TACplot2.pdf")
hist(ccS, xlim = c(-0.4, 0.4),
    xlab = "Correlation coefficients of random sample",
    main = NULL)
abline(v = cc0, col = "red", lwd = 1, lty = 2)
text(cc0 - 0.1, 1875, "original correlation coefficient \nfor successive years")
dev.off()

# calculating the estimated p-value
p_estimate <- sum(ccS > cc0) / 10000
cat("The estimated p-value is", p_estimate)
**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 


**********************************************************************
Temp :  num [1:100] 23.8 24.7 24.7 24.5 24.9 ...
Year :  int [1:100] 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 ...
null device 
          1 
The correlation between successive years is 0.3261697null device 
          1 
The estimated p-value is 1e-04
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.64745s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: boilerplate.R
# Created: Oct 2020
#
# A boilerplate R script

rm(list = ls())

MyFunction <- function(Arg1, Arg2) {

    # Statements involving Arg1, Arg2:
    # print Arg1's type
    print(paste("Argument", as.character(Arg1), "is a", class(Arg1)))
    # print Arg2's type
    print(paste("Argument", as.character(Arg2), "is a", class(Arg2)))

    return(c(Arg1, Arg2)) # this is optional, but very useful
}

MyFunction(1, 2) # test the function
MyFunction("Riki", "Tiki") # a different test
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.18164s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: apply1.R
# Created: Oct 2020
#
# Script illustrates the use of apply to apply a function to rows/columns of a
# matrix

rm(list = ls())

## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print(RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print(RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print(ColMeans)

ColVars <- apply(M, 2, var)
print(ColVars)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1]  0.27844668  0.37975763  0.28916667  0.57489354  0.63671564 -0.66818121
 [7] -0.03715027 -0.19747209 -0.14518337 -0.35152627
 [1] 0.4538647 0.8027619 1.0322138 0.5287476 1.2159183 1.1863356 0.6470068
 [8] 0.5740685 1.0342593 1.3365933
 [1] -0.214395787 -0.099438408 -0.287875483  0.248440742  0.006769597
 [6] -0.539000683 -0.018572062  0.678011114  0.835948593  0.149579328
 [1] 1.0894092 0.5321432 0.5695908 1.2188867 0.6167661 1.0918703 1.4739438
 [8] 1.0991822 0.6728868 0.4476700

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.16453s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: PP_Regress.R
# Created: Nov 2020
#
# Script draws and saves a pdf of regression analysis using data subsetted by
# the Predator.lifestage field and writes the accompanying regression results to
# a formatted table in csv in the results directory

# clear out workspace
rm(list = ls())

require(ggplot2)
require(dplyr)
require(tidyr)
require(broom)

# load data
df <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
dplyr::glimpse(df)

# convert masses in mg to g
for (i in 1:nrow(df)){
  if (df$Prey.mass.unit[i] == "mg"){
    df$Prey.mass.unit[i] <- "g"
    df$Prey.mass[i] <- df$Prey.mass[i] / 1000
  }
}

# plot the predator against prey mass by feeding type and predator lifestage
# using the linear model method
p <- qplot(Prey.mass, Predator.mass, data = df, log="xy",
           xlab = "Prey mass in grams",
           ylab = "Predator mass in grams",
           colour = Predator.lifestage,
           shape = I(3)) +
       geom_smooth(method = "lm", fullrange = TRUE) + # plot linear regressions
       # facet by feeding interaction
       facet_grid(Type.of.feeding.interaction ~ .) +
       theme_bw() +
       theme(legend.position = "bottom",
             panel.border = element_rect(colour = "grey", fill = NA)) +
       guides(colour = guide_legend(nrow = 1)) + # legend on one line
       theme(legend.title = element_text(size = 8, face="bold"),
             panel.border = element_rect(colour = "black", fill = NA,
                                         size = 0.2))

pdf("../Results/PP_Regress_Results.pdf")
p
dev.off()

# calculate the regression
linreg <- df %>%
          group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
          do(tidy(lm(log(Predator.mass) ~ log(Prey.mass), .)))

# linreg returns:
# piscivorous postlarva/juvenile Prey.mass NA NA NA NA
# planktivorous juvenile Prey.mass 6.557377e+03 NaN NaN NaN

# change Type of feeding interaction and Predator lifestage into factors
df$Type.of.feeding.interaction <- as.factor(df$Type.of.feeding.interaction)
df$Predator.lifestage <- as.factor(df$Predator.lifestage)
# subset the corresponding factors which produced NA and NaN results
ss1 <- df[which(df$Type.of.feeding.interaction == "piscivorous" &
                df$Predator.lifestage == "postlarva/juvenile"), ]
ss2 <- df[which(df$Type.of.feeding.interaction == "planktivorous" &
                df$Predator.lifestage == "juvenile"), ]

linregb <- df %>%
  # filtering entries found in the above subsets
  filter(!Record.number %in% c(30914, 30929, 277, 321)) %>%
  # select columns required and group by feeding type and predator lifestage
  dplyr::select(Predator.mass, Prey.mass, Predator.lifestage,
                Type.of.feeding.interaction) %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  # lm calculation and store calculations to a dataframe
  do(mod = lm(log(Predator.mass) ~ log(Prey.mass), data = .)) %>%
  mutate(Regression.slope = summary(mod)$coeff[2],
         Regression.intercept = summary(mod)$coeff[1],
         R.squared = summary(mod)$adj.r.squared,
         F.statistic = summary(mod)$fstatistic[1],
         p.value = summary(mod)$coeff[8]) %>%
  # remove mod column
  dplyr::select(-mod)

write.csv(linregb, "../Results/PP_Regress_Results.csv")
**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 


**********************************************************************
Rows: 34,931
Columns: 15
$ Record.number               <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13…
$ In.refID                    <chr> "ATSH063", "ATSH080", "ATSH089", "ATSH143…
$ IndividualID                <chr> "1", "2", "3", "4", "5", "6", "7", "8", "…
$ Predator                    <chr> "Rhizoprionodon terraenovae", "Rhizoprion…
$ Predator.common.name        <chr> "Atlantic sharpnose shark", "Atlantic sha…
$ Predator.taxon              <chr> "ectotherm vertebrate", "ectotherm verteb…
$ 
**********************************************************************

Encountered error or warning:
Loading required package: ggplot2
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: tidyr
Loading required package: broom
`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: MyBars.R
# Created: Nov 2020
#
# This script demonstrates how to annotate a plot and saves the resulting figure
# to the results directory

rm(list = ls())

require(ggplot2)

a <- read.table("../Data/Results.txt", header = TRUE)

head(a)

a$ymin <- rep(0, dim(a)[1]) # append a column of zeros

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y1,
  size = (0.5)
),
colour = "#E69F00",
alpha = 1 / 2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y2,
  size = (0.5)
),
colour = "#56B4E9",
alpha = 1 / 2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y3,
  size = (0.5)
),
colour = "#D55E00",
alpha = 1 / 2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis", breaks = seq(3, 5, by = 0.05)) +
  scale_y_continuous("My y axis") +
  theme_bw() +
  theme(legend.position = "none")

pdf("../Results/MyBars.pdf")
p
dev.off()
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************
         x   y1   y2 y3 Label
1 3.515424 4320 4320  0  <NA>
2 3.533984 2160 2160  0  <NA>
3 3.557647 4320 4320  0  <NA>
4 3.569953 4320 4320  0  <NA>
5 3.578984 8640 8640  0  <NA>
6 3.585665 2160 2160  0  <NA>
null device 
          1 

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2
Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: DataWrang.R
# Created: Oct 2020
#
# Script uses base R packages to wrangle the Pound Hill Dataset

rm(list = ls())

################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",
    header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows
MyData <- t(MyData)
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] <- 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1, ], stringsAsFactors = F)
#stringsAsFactors = F is important!
colnames(TempData) <- MyData[1, ] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

# ?melt #check out the melt function

MyWrangledData <- melt(TempData, id = c("Cultivation", "Block", "Plot",
    "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

require(tidyverse)

tibble::as_tibble(MyWrangledData)

dplyr::glimpse(MyWrangledData)

utils::View(MyWrangledData)
**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error or warning:
Loading required package: reshape2
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.2     ✔ purrr   0.3.4
✔ tibble  3.0.3     ✔ dplyr   1.0.1
✔ tidyr   1.1.1     ✔ stringr 1.4.0
✔ readr   1.3.1     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: control_flow.R
# Created: Oct 2020
#
# Script illustrates the use of control flow in R

rm(list = ls())

## if statements ##

a <- TRUE
if (a == TRUE) {
    print("a is TRUE")
    } else {
    print("a is FALSE")
    }

# writing an if statement in one line
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {
    print("Less than a half")
    }

# code readability is important, so avoid squeezing control flow blocks into a
# single line

## for loops ##

for (i in 1:10) {
    j <- i * i
    print(paste(i, " squared is", j))
}

# loop over a vector of strings
for (species in c("Heliodoxa rubinoides",
                 "Boissonneaua jardini",
                 "Sula nebouxii")) {
    print(paste("The species is", species))
}

# for loop using a pre-existing vector
v1 <- c("a", "bc", "def")
for (i in v1) {
    print(i)
}

## while loops ##

i <- 0
while (i < 10) {
    i <- i + 1
    print(i ^ 2)
}
**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "Less than a half"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.22503s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: Vectorize1.R
# Created: Oct 2020
#
# Script demonstrates vectorization, where it is an apporach which directly
# applies compiled, optimized code to run an operation on a vector, matrix or a
# higher-dimensional data structure (like an R array), instead of performing the
# operation element-wise on the data structure. Script compares the speed
# between the vectorized and non-vectorized functions.
#
# ARGUMENTS:
# a vector, matrix or higher-dimensional data structure
#
# OUTPUT
# time taken to sum with a written loop and sum with inbuilt sum()

rm(list = ls())

M <- matrix(runif(1000000), 1000, 1000)

SumAllElements <- function(M) {
    Dimensions <- dim(M)
    Tot <- 0
    for (i in 1:Dimensions[1]) {
        for (j in 1:Dimensions[2]) {
            Tot <- Tot + M[i, j]
        }
    }
    return(Tot)
}

print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.077   0.004   0.080 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.002   0.000   0.002 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.35280s

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: sample.R
# Created: Oct 2020
#
# This script illustrates how lapply and sapply work and also how to
# sample random numbers

rm(list = ls())

##### Functions #####

## a function to take a sample of size n from a population "popn" and return its
## mean
myexperiment <- function(popn, n) {
    pop_sample <- sample(popn, n, replace = FALSE)
    return(mean(pop_sample))
}

## calculate means using a for loop without preallocation:
loopy_sample1 <- function(popn, n, num) {
    result1 <- vector() # initialize empty vector of size 1
    for (i in 1:num) {
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## to run "num" iterations of the experiment using a for loop on a vector with
## preallocation:
loopy_sample2 <- function(popn, n, num) {
    result2 <- vector(, num) # preallocate expected size
    for (i in 1:num) {
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

## to run "num" iterations ofthe experiment using a for loop on a list with
## preallocation:
loopy_sample3 <- function(popn, n, num) {
    result3 <- vector("list", num) # preallocate expected size
    for (i in 1:num) {
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}

## to run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## to run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
    result5 <- sapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}

popn <- rnorm(1000) # generate the population
hist(popn)

n <- 20 # sample size for each experiment
num <- 1000 # number of times to rerun the experiment

print("The loopy, non-preallocation approach takes:")
print(system.time(loopy_sample1(popn, n, num)))

print("The loopy, but with preallocation approach takes:")
print(system.time(loopy_sample2(popn, n, num)))

print("The loopy, non-preallocation approach on a list takes:")
print(system.time(loopy_sample3(popn, n, num)))

print("The vectorized lapply apporach takes:")
print(system.time(lapply_sample(popn, n, num)))

print("The vectorized sapply approach takes:")
print(system.time(sapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "The loopy, non-preallocation approach takes:"
   user  system elapsed 
  0.025   0.012   0.037 
[1] "The loopy, but with preallocation approach takes:"
   user  system elapsed 
  0.016   0.000   0.016 
[1] "The loopy, non-preallocation approach on a list takes:"
   user  system elapsed 
  0.014   0.000   0.015 
[1] "The vectorized lapply apporach takes:"
   user  system elapsed 
  0.011   0.000   0.011 
[1] "The vectorized sapply approach takes:"
   user  system elapsed 
  0.012   0.000   0.
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.41818s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: apply2.R
# Created: Oct 2020
#
# Script contains a function SomeOperation, which takes an input v, if sum of v
# is greater than zero, the function multiplies that value by 100. So if v has
# positive and negative numbers, and the sum comes out to be positive, only then
# does it multiply all the valus in v by 100 and return them

rm(list = ls())

SomeOperation <- function(v) {
    if (sum(v) > 0) {
        return(v * 100)
    }
    return(v)
}

M <- matrix(rnorm(100), 10, 10)
print(apply(M, 1, SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
            [,1]       [,2]         [,3]       [,4]        [,5]        [,6]
 [1,] -0.4909779 -0.5109190  0.003569837  1.1607778 -0.88212485   -4.713861
 [2,] -0.5608617  0.7853028  0.144272291 -0.2919200  0.96898040   -4.395533
 [3,] -0.7801553 -1.6800663 -0.110226073  0.2340808 -2.79983178  121.752782
 [4,] -0.3169807 -0.8845763 -2.359357612 -1.1289429 -0.37559004   57.641396
 [5,] -1.0937578 -0.1668971 -0.020523396 -1.2323125 -0.69618948   98.786497
 [6,]  0.2791925 -0.3041434 -0.799290837  1.1
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.20891s

======================================================================
Inspecting script file Ricker.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: Ricker.R
# Created: Oct 2020
#
# This script runs a simulation of the Ricker model and returns a vector of
# length generations
#
# ARGUMENTS:
# N0 = initial density of population
# r = intrinsic growth rate
# K = carrying capacity of the environment
#
# OUTPUT
# density of population after a number of generations

rm(list = ls())

Ricker <- function(N0 = 1, r = 1, K = 10, generations = 50) {
    N <- rep(NA, generations) # creates a vector of NA

    N[1] <- N0
    for (t in 2:generations) {
        N[t] <- N[t - 1] * exp(r * (1.0 - (N[t - 1] / K)))
    }
    return(N)
}

plot(Ricker(generations = 10), type = "l")
**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.24984s

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: break.R
# Created: Oct 2020
#
# Script illustrates how to break out of a loop

rm(list = ls())

## breaking out of a loop ##

i <- 0 #Initialize i
    while (i < Inf) {
        if (i == 10) {
            break # break out of the while loop!
            }
        else {
            cat("i equals ", i, " \n")
            i <- i + 1 # update i
   }
}
**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.18648s

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: next.R
# Created: Oct 2020
#
# Script illustrates the use of next

rm(list = ls())

## next ##

for (i in 1:10) {
    if ((i %% 2) == 0) # check if the number is odd
        next # pass to next iteration of loop
    print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.19979s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: R_conditionals.R
# Created: Oct 2020
#
# Script illustrates the use of conditionals

rm(list = ls())

# Checks if an integer is even
is.even <- function(n=2) {
    if (n %% 2 == 0) {
        return(paste(n, "is even!"))
    }
    return(paste(n, "is odd!"))
}

is.even(6)

# Checks if a number is a power of 2
is.power2 <- function(n=2) {
    if (log2(n) %% 1 == 0) {
        return(paste(n, "is a power of 2!"))
    }
    return(paste(n, "is not a power of 2!"))
}

is.power2(4)

# Checks if a number is prime
is.prime <- function(n) {
    if (n == 0) {
        return(paste(n, "is a zero!"))
    }
    if (n == 1) {
        return(paste(n, "is just a unit!"))
    }
    ints <- 2:(n - 1)
    if (all(n %% ints != 0)) {
        return(paste(n, "is a prime!"))
    }
    return(paste(n, "is a composite!"))
}

is.prime(3)
**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.16049s

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: Girko.R
# Created: Nov 2020
#
# This script plots the Girko's law simulation, and saves the resulting figure
# to the results directory

rm(list = ls())

require(ggplot2)

# function that returns an ellipse
build_ellipse <- function(hradius, vradius) {
  npoints <- 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix

M <- matrix(rnorm(N * N), N, N) # Build the matrix

eigvals <- eigen(M)$values # Find the eigenvalues

# Build a dataframe
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals))

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF,
                      aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))

pdf("../Results/Girko.pdf")
p
dev.off()
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************
null device 
          1 

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2

======================================================================
Inspecting script file GPDD_Data.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@durham.ac.uk)
# Script: GPDD_Data.R
# Created: Nov 2020
#
# Script creates a world map and superimposes it on all the locations from which
# data were provided in the GPDD dataframe

rm(list = ls())

require(maps)

# load GPDD data
load("../Data/GPDDFiltered.RData")

# draw the map
map(database = "world",
    fill = TRUE,
    col = "black",
    bg = "black",
    ylim = c(-60, 90),
    border = "white")
# plot the points
points(x = gpdd$long,
       y = gpdd$lat,
       col = "yellow",
       pch = 10,
       cex = 0.7,
       lwd = 1.1)

# Bias is reflected by the uneven distribution of data points in data, which are
# mostly located in the West Coast of North America and Europe. From past
# experience with passerine data, this distribution likely resulted from the
# developmental stage of countries, where North America and Europe had the
# resources to study these species present.
**********************************************************************

Testing GPDD_Data.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: maps

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: basic_io.R
# Created: Oct 2020
#
# A simple script to illustrate R input-output
# Run line by line and check inputs outputs to understand what is happening

rm(list = ls())

MyData <- read.csv("../Data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../Results/MyData.csv") # write it out as a new file

# append to it
write.table(MyData[1, ], file = "../Results/MyData.csv", append = TRUE)

write.csv(MyData, "../Results/MyData.csv", row.names = TRUE) # write row names

# ignore column names
write.table(MyData, "../Results/MyData.csv", col.names = FALSE)

print("Script complete!")
**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Script complete!"

**********************************************************************

Encountered error or warning:
Warning message:
In write.table(MyData[1, ], file = "../Results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:

**********************************************************************
# Author: Yewshen Lim (y.lim20@imperial.ac.uk)
# Script: DataWrangTidy.R
# Created: Oct 2020
#
# Script uses dplyr and tidyr to wrangle the Pound Hill Dataset

rm(list = ls())

################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

require(dplyr)
require(tidyr)

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
dplyr::glimpse(MyData) # tidier str()

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData)
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1, ], stringsAsFactors = F) 
#stringsAsFactors = F is important!
colnames(TempData) <- MyData[1, ] # assign column names from original data

############# Convert from wide to long format  ###############

# using dplyr
MyWrangledData <- TempData %>% 
    gather(Species, Count, -Cultivation, -Block, -Plot, -Quadrat)

# set Cultivation, Block, Plot, Quadrat columns as factors and count as numeric
MyWrangledData <- MyWrangledData %>%
    mutate(Cultivation = factor(Cultivation),
           Block = factor(Block),
           Plot = factor(Plot),
           Quadrat = factor(Quadrat),
           Count = as.integer(Count))

dplyr::glimpse(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error or warning:
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: tidyr

======================================================================
======================================================================
Finished running scripts

Ran into 10 errors or warnings

Total time used: 20.84s 

======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 92.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!